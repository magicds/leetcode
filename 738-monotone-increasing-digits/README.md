---
date: [2020-12-15 22:03:50]
---

# [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)

给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）

示例 1:

```
输入: N = 10
输出: 9
```

示例 2:

```
输入: N = 1234
输出: 1234
```

示例 3:

```
输入: N = 332
输出: 299
```

说明: N 是在 [0, 10^9] 范围内的一个整数。

## 解决方案

开始是完全没有想法的，没想法就先做呗，先上暴力破解，首先能一定程度解决问题，其次也需会在过程中有所发现。

暴力破解首先仅需判断当前是不是单调递增的，若是，直接返回即可；否则将数字缩小继续尝试。

毫无疑问，暴力解法是不可能通过的。

做的过程中，确实来了点想法，或者说观察到点规律:

- 最好的情况就是输入本身就是单调递增的
- 最后的结果中会含有多个9，如 `10 -> 9`, `100 -> 99`, `12375 -> 12369`, `332 -> 299`, `777616726 -> 699999999`
- 继续总结上一步的9，其规律为 **数字从不符合的单调递增之后的位置都会变成9**, 而其前面的位置逐位递减使得满足单调递增

| 输入    | 不符合的位置（下标） | 递减使得前面单调递增，并将后续替换为9 | 输出    |
| ------- | -------------------- | ------------------------------------- | ------- |
| `10`    | `1`                  | `00`(0) ➡️ `09`                        | `9`     |
| `100`   | `1`                  | `000`(0)➡️ `099`                       | `99`    |
| `12375` | `4`                  | `12369`                               | `12369` |
| `332`   | `2`                  | `329`(1) ➡️ `229`(0) ➡️ `299`           | `299`   |
| `77616` | `2`                  | `76616`(1) ➡️ `66616`(0) ➡️ `69999`     | `69999` |

因此代码如下：

```js
/**
 * @param {number} N
 * @return {number}
 */
var monotoneIncreasingDigits = function (N) {
  var arr = (N + "").split("");
  let i = 1; // 记录输入的第几位不符合单调递增
  while (i < arr.length && arr[i - 1] <= arr[i]) {
    i++;
  }
  if (i < arr.length) {
    while (i > 0 && arr[i - 1] > arr[i]) {
      // 从不符合的位置往前开始递减 确保前面都符合 单调递增 更新下标
      arr[i - 1] -= 1;
      i--;
    }
    i++;// 递减位置之后的元素全部变成9即可 前面递减保障了小于输入 替换为9可保障最大
    for (; i < arr.length; i++) {
      arr[i] = 9;
    }
  }
  return parseInt(arr.join(""), 10);
};
```
